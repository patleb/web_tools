aliases:
  - &shape [const Vsize_t &, shape]
  <%- compile_vars[:numeric_types].each_value do |type| -%>
  - &fill_value_<%= type %> [const O<%= type %> &, fill_value = nil]
  <%- end -%>

module Tensor:
  enum Type | Tensor::Type: [<%= compile_vars[:numeric_types].keys.join(', ') %>]

  class Base | Tensor::Base:
    attr_reader: [size, rank, type]

    def:
      shape | _shape_:

  <% compile_vars[:numeric_types].each do |tensor_type, type| %>
  class <%= tensor_type %> < Tensor::Base:
    attr_reader: [fill_value]

    def:
      initialize | Tensor::<%= tensor_type %>.COPY:
        - { [ *shape, *fill_value_<%= type %> ] }
        - { [ [const V<%= type %> &, values], *shape, *fill_value_<%= type %> ] }
      to_sql:
      "== | operator==":
      "[] | operator[]":
        - { const <%= type %> & const: [const Vsize_t & indexes] }
      "[]=": >
        [](Tensor::<%= tensor_type %> & self, const Vsize_t & indexes, const <%= type %> & value) -> const <%= type %> & {
          self[indexes] = value;
          return value;
        }
      first:
      last:
      values:
      slice:
      reshape: >
        [](Tensor::<%= tensor_type %> & self, const Vsize_t & shape) -> Tensor::<%= tensor_type %> & {
          self.reshape(shape);
          return self;
        }
      seq: >
        [](Tensor::<%= tensor_type %> & self, <%= type %> start) -> Tensor::<%= tensor_type %> & {
          self.seq();
          return self;
        }
  <% end %>
